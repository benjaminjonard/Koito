// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: listen.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countListens = `-- name: CountListens :one
SELECT COUNT(*) AS total_count
FROM listens l
WHERE l.listened_at BETWEEN $1 AND $2
`

type CountListensParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
}

func (q *Queries) CountListens(ctx context.Context, arg CountListensParams) (int64, error) {
	row := q.db.QueryRow(ctx, countListens, arg.ListenedAt, arg.ListenedAt_2)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countListensFromArtist = `-- name: CountListensFromArtist :one
SELECT COUNT(*) AS total_count
FROM listens l
JOIN artist_tracks at ON l.track_id = at.track_id
WHERE l.listened_at BETWEEN $1 AND $2
  AND at.artist_id = $3
`

type CountListensFromArtistParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	ArtistID     int32
}

func (q *Queries) CountListensFromArtist(ctx context.Context, arg CountListensFromArtistParams) (int64, error) {
	row := q.db.QueryRow(ctx, countListensFromArtist, arg.ListenedAt, arg.ListenedAt_2, arg.ArtistID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countListensFromRelease = `-- name: CountListensFromRelease :one
SELECT COUNT(*) AS total_count
FROM listens l
JOIN tracks t ON l.track_id = t.id
WHERE l.listened_at BETWEEN $1 AND $2
  AND t.release_id = $3
`

type CountListensFromReleaseParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	ReleaseID    int32
}

func (q *Queries) CountListensFromRelease(ctx context.Context, arg CountListensFromReleaseParams) (int64, error) {
	row := q.db.QueryRow(ctx, countListensFromRelease, arg.ListenedAt, arg.ListenedAt_2, arg.ReleaseID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countListensFromTrack = `-- name: CountListensFromTrack :one
SELECT COUNT(*) AS total_count
FROM listens l
WHERE l.listened_at BETWEEN $1 AND $2
  AND l.track_id = $3
`

type CountListensFromTrackParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	TrackID      int32
}

func (q *Queries) CountListensFromTrack(ctx context.Context, arg CountListensFromTrackParams) (int64, error) {
	row := q.db.QueryRow(ctx, countListensFromTrack, arg.ListenedAt, arg.ListenedAt_2, arg.TrackID)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const countTimeListened = `-- name: CountTimeListened :one
SELECT COALESCE(SUM(t.duration), 0)::BIGINT AS seconds_listened
FROM listens l
JOIN tracks t ON l.track_id = t.id
WHERE l.listened_at BETWEEN $1 AND $2
`

type CountTimeListenedParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
}

func (q *Queries) CountTimeListened(ctx context.Context, arg CountTimeListenedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTimeListened, arg.ListenedAt, arg.ListenedAt_2)
	var seconds_listened int64
	err := row.Scan(&seconds_listened)
	return seconds_listened, err
}

const countTimeListenedToArtist = `-- name: CountTimeListenedToArtist :one
SELECT COALESCE(SUM(t.duration), 0)::BIGINT AS seconds_listened
FROM listens l
JOIN tracks t ON l.track_id = t.id
JOIN artist_tracks at ON t.id = at.track_id
WHERE l.listened_at BETWEEN $1 AND $2
  AND at.artist_id = $3
`

type CountTimeListenedToArtistParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	ArtistID     int32
}

func (q *Queries) CountTimeListenedToArtist(ctx context.Context, arg CountTimeListenedToArtistParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTimeListenedToArtist, arg.ListenedAt, arg.ListenedAt_2, arg.ArtistID)
	var seconds_listened int64
	err := row.Scan(&seconds_listened)
	return seconds_listened, err
}

const countTimeListenedToRelease = `-- name: CountTimeListenedToRelease :one
SELECT COALESCE(SUM(t.duration), 0)::BIGINT AS seconds_listened
FROM listens l
JOIN tracks t ON l.track_id = t.id
WHERE l.listened_at BETWEEN $1 AND $2
  AND t.release_id = $3
`

type CountTimeListenedToReleaseParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	ReleaseID    int32
}

func (q *Queries) CountTimeListenedToRelease(ctx context.Context, arg CountTimeListenedToReleaseParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTimeListenedToRelease, arg.ListenedAt, arg.ListenedAt_2, arg.ReleaseID)
	var seconds_listened int64
	err := row.Scan(&seconds_listened)
	return seconds_listened, err
}

const countTimeListenedToTrack = `-- name: CountTimeListenedToTrack :one
SELECT COALESCE(SUM(t.duration), 0)::BIGINT AS seconds_listened
FROM listens l
JOIN tracks t ON l.track_id = t.id
WHERE l.listened_at BETWEEN $1 AND $2
  AND t.id = $3
`

type CountTimeListenedToTrackParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	ID           int32
}

func (q *Queries) CountTimeListenedToTrack(ctx context.Context, arg CountTimeListenedToTrackParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTimeListenedToTrack, arg.ListenedAt, arg.ListenedAt_2, arg.ID)
	var seconds_listened int64
	err := row.Scan(&seconds_listened)
	return seconds_listened, err
}

const deleteListen = `-- name: DeleteListen :exec
DELETE FROM listens WHERE track_id = $1 AND listened_at = $2
`

type DeleteListenParams struct {
	TrackID    int32
	ListenedAt time.Time
}

func (q *Queries) DeleteListen(ctx context.Context, arg DeleteListenParams) error {
	_, err := q.db.Exec(ctx, deleteListen, arg.TrackID, arg.ListenedAt)
	return err
}

const getLastListensFromArtistPaginated = `-- name: GetLastListensFromArtistPaginated :many
SELECT 
  l.track_id, l.listened_at, l.client, l.user_id,
  t.title AS track_title,
  t.release_id AS release_id,
  get_artists_for_track(t.id) AS artists
FROM listens l
JOIN tracks_with_title t ON l.track_id = t.id
JOIN artist_tracks at ON t.id = at.track_id 
WHERE at.artist_id = $5
  AND l.listened_at BETWEEN $1 AND $2
ORDER BY l.listened_at DESC
LIMIT $3 OFFSET $4
`

type GetLastListensFromArtistPaginatedParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	Limit        int32
	Offset       int32
	ArtistID     int32
}

type GetLastListensFromArtistPaginatedRow struct {
	TrackID    int32
	ListenedAt time.Time
	Client     *string
	UserID     int32
	TrackTitle string
	ReleaseID  int32
	Artists    []byte
}

func (q *Queries) GetLastListensFromArtistPaginated(ctx context.Context, arg GetLastListensFromArtistPaginatedParams) ([]GetLastListensFromArtistPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getLastListensFromArtistPaginated,
		arg.ListenedAt,
		arg.ListenedAt_2,
		arg.Limit,
		arg.Offset,
		arg.ArtistID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastListensFromArtistPaginatedRow
	for rows.Next() {
		var i GetLastListensFromArtistPaginatedRow
		if err := rows.Scan(
			&i.TrackID,
			&i.ListenedAt,
			&i.Client,
			&i.UserID,
			&i.TrackTitle,
			&i.ReleaseID,
			&i.Artists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastListensFromReleasePaginated = `-- name: GetLastListensFromReleasePaginated :many
SELECT 
  l.track_id, l.listened_at, l.client, l.user_id,
  t.title AS track_title,
  t.release_id AS release_id,
  get_artists_for_track(t.id) AS artists
FROM listens l
JOIN tracks_with_title t ON l.track_id = t.id
WHERE l.listened_at BETWEEN $1 AND $2
  AND t.release_id = $5
ORDER BY l.listened_at DESC
LIMIT $3 OFFSET $4
`

type GetLastListensFromReleasePaginatedParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	Limit        int32
	Offset       int32
	ReleaseID    int32
}

type GetLastListensFromReleasePaginatedRow struct {
	TrackID    int32
	ListenedAt time.Time
	Client     *string
	UserID     int32
	TrackTitle string
	ReleaseID  int32
	Artists    []byte
}

func (q *Queries) GetLastListensFromReleasePaginated(ctx context.Context, arg GetLastListensFromReleasePaginatedParams) ([]GetLastListensFromReleasePaginatedRow, error) {
	rows, err := q.db.Query(ctx, getLastListensFromReleasePaginated,
		arg.ListenedAt,
		arg.ListenedAt_2,
		arg.Limit,
		arg.Offset,
		arg.ReleaseID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastListensFromReleasePaginatedRow
	for rows.Next() {
		var i GetLastListensFromReleasePaginatedRow
		if err := rows.Scan(
			&i.TrackID,
			&i.ListenedAt,
			&i.Client,
			&i.UserID,
			&i.TrackTitle,
			&i.ReleaseID,
			&i.Artists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastListensFromTrackPaginated = `-- name: GetLastListensFromTrackPaginated :many
SELECT 
  l.track_id, l.listened_at, l.client, l.user_id,
  t.title AS track_title,
  t.release_id AS release_id,
  get_artists_for_track(t.id) AS artists
FROM listens l
JOIN tracks_with_title t ON l.track_id = t.id
WHERE l.listened_at BETWEEN $1 AND $2
  AND t.id = $5
ORDER BY l.listened_at DESC
LIMIT $3 OFFSET $4
`

type GetLastListensFromTrackPaginatedParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	Limit        int32
	Offset       int32
	ID           int32
}

type GetLastListensFromTrackPaginatedRow struct {
	TrackID    int32
	ListenedAt time.Time
	Client     *string
	UserID     int32
	TrackTitle string
	ReleaseID  int32
	Artists    []byte
}

func (q *Queries) GetLastListensFromTrackPaginated(ctx context.Context, arg GetLastListensFromTrackPaginatedParams) ([]GetLastListensFromTrackPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getLastListensFromTrackPaginated,
		arg.ListenedAt,
		arg.ListenedAt_2,
		arg.Limit,
		arg.Offset,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastListensFromTrackPaginatedRow
	for rows.Next() {
		var i GetLastListensFromTrackPaginatedRow
		if err := rows.Scan(
			&i.TrackID,
			&i.ListenedAt,
			&i.Client,
			&i.UserID,
			&i.TrackTitle,
			&i.ReleaseID,
			&i.Artists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastListensPaginated = `-- name: GetLastListensPaginated :many
SELECT 
  l.track_id, l.listened_at, l.client, l.user_id,
  t.title AS track_title,
  t.release_id AS release_id,
  get_artists_for_track(t.id) AS artists
FROM listens l
JOIN tracks_with_title t ON l.track_id = t.id
WHERE l.listened_at BETWEEN $1 AND $2
ORDER BY l.listened_at DESC
LIMIT $3 OFFSET $4
`

type GetLastListensPaginatedParams struct {
	ListenedAt   time.Time
	ListenedAt_2 time.Time
	Limit        int32
	Offset       int32
}

type GetLastListensPaginatedRow struct {
	TrackID    int32
	ListenedAt time.Time
	Client     *string
	UserID     int32
	TrackTitle string
	ReleaseID  int32
	Artists    []byte
}

func (q *Queries) GetLastListensPaginated(ctx context.Context, arg GetLastListensPaginatedParams) ([]GetLastListensPaginatedRow, error) {
	rows, err := q.db.Query(ctx, getLastListensPaginated,
		arg.ListenedAt,
		arg.ListenedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLastListensPaginatedRow
	for rows.Next() {
		var i GetLastListensPaginatedRow
		if err := rows.Scan(
			&i.TrackID,
			&i.ListenedAt,
			&i.Client,
			&i.UserID,
			&i.TrackTitle,
			&i.ReleaseID,
			&i.Artists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListensExportPage = `-- name: GetListensExportPage :many
SELECT
    l.listened_at,
    l.user_id,
    l.client,

    -- Track info
    t.id AS track_id,
    t.musicbrainz_id AS track_mbid,
    t.duration AS track_duration,
    (
        SELECT json_agg(json_build_object(
            'alias', ta.alias,
            'source', ta.source,
            'is_primary', ta.is_primary
        ))
        FROM track_aliases ta
        WHERE ta.track_id = t.id
    ) AS track_aliases,

    -- Release info
    r.id AS release_id,
    r.musicbrainz_id AS release_mbid,
    r.image AS release_image,
    r.image_source AS release_image_source,
    r.various_artists,
    (
        SELECT json_agg(json_build_object(
            'alias', ra.alias,
            'source', ra.source,
            'is_primary', ra.is_primary
        ))
        FROM release_aliases ra
        WHERE ra.release_id = r.id
    ) AS release_aliases,

    -- Artists
    (
        SELECT json_agg(json_build_object(
            'id', a.id,
            'musicbrainz_id', a.musicbrainz_id,
            'image', a.image,
            'image_source', a.image_source,
            'aliases', (
                SELECT json_agg(json_build_object(
                    'alias', aa.alias,
                    'source', aa.source,
                    'is_primary', aa.is_primary
                ))
                FROM artist_aliases aa
                WHERE aa.artist_id = a.id
            )
        ))
        FROM artist_tracks at
        JOIN artists a ON a.id = at.artist_id
        WHERE at.track_id = t.id
    ) AS artists

FROM listens l
JOIN tracks t ON l.track_id = t.id
JOIN releases r ON t.release_id = r.id

WHERE l.user_id = $2::int
  AND (l.listened_at, l.track_id) > ($3::timestamptz, $4::int)
ORDER BY l.listened_at, l.track_id
LIMIT $1
`

type GetListensExportPageParams struct {
	Limit      int32
	UserID     int32
	ListenedAt time.Time
	TrackID    int32
}

type GetListensExportPageRow struct {
	ListenedAt         time.Time
	UserID             int32
	Client             *string
	TrackID            int32
	TrackMbid          *uuid.UUID
	TrackDuration      int32
	TrackAliases       []byte
	ReleaseID          int32
	ReleaseMbid        *uuid.UUID
	ReleaseImage       *uuid.UUID
	ReleaseImageSource pgtype.Text
	VariousArtists     bool
	ReleaseAliases     []byte
	Artists            []byte
}

func (q *Queries) GetListensExportPage(ctx context.Context, arg GetListensExportPageParams) ([]GetListensExportPageRow, error) {
	rows, err := q.db.Query(ctx, getListensExportPage,
		arg.Limit,
		arg.UserID,
		arg.ListenedAt,
		arg.TrackID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListensExportPageRow
	for rows.Next() {
		var i GetListensExportPageRow
		if err := rows.Scan(
			&i.ListenedAt,
			&i.UserID,
			&i.Client,
			&i.TrackID,
			&i.TrackMbid,
			&i.TrackDuration,
			&i.TrackAliases,
			&i.ReleaseID,
			&i.ReleaseMbid,
			&i.ReleaseImage,
			&i.ReleaseImageSource,
			&i.VariousArtists,
			&i.ReleaseAliases,
			&i.Artists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertListen = `-- name: InsertListen :exec
INSERT INTO listens (track_id, listened_at, user_id, client)
VALUES ($1, $2, $3, $4)
ON CONFLICT DO NOTHING
`

type InsertListenParams struct {
	TrackID    int32
	ListenedAt time.Time
	UserID     int32
	Client     *string
}

func (q *Queries) InsertListen(ctx context.Context, arg InsertListenParams) error {
	_, err := q.db.Exec(ctx, insertListen,
		arg.TrackID,
		arg.ListenedAt,
		arg.UserID,
		arg.Client,
	)
	return err
}

const listenActivity = `-- name: ListenActivity :many
WITH buckets AS (
  SELECT generate_series($1::timestamptz, $2::timestamptz, $3::interval) AS bucket_start
),
bucketed_listens AS (
  SELECT
    b.bucket_start,
    COUNT(l.listened_at) AS listen_count
  FROM buckets b
  LEFT JOIN listens l
    ON l.listened_at >= b.bucket_start
    AND l.listened_at < b.bucket_start + $3::interval
  GROUP BY b.bucket_start
  ORDER BY b.bucket_start
)
SELECT bucket_start, listen_count FROM bucketed_listens
`

type ListenActivityParams struct {
	Column1 time.Time
	Column2 time.Time
	Column3 pgtype.Interval
}

type ListenActivityRow struct {
	BucketStart time.Time
	ListenCount int64
}

func (q *Queries) ListenActivity(ctx context.Context, arg ListenActivityParams) ([]ListenActivityRow, error) {
	rows, err := q.db.Query(ctx, listenActivity, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListenActivityRow
	for rows.Next() {
		var i ListenActivityRow
		if err := rows.Scan(&i.BucketStart, &i.ListenCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listenActivityForArtist = `-- name: ListenActivityForArtist :many
WITH buckets AS (
  SELECT generate_series($1::timestamptz, $2::timestamptz, $3::interval) AS bucket_start
),
filtered_listens AS (
  SELECT l.track_id, l.listened_at, l.client, l.user_id
  FROM listens l
  JOIN artist_tracks t ON l.track_id = t.track_id
  WHERE t.artist_id = $4
),
bucketed_listens AS (
  SELECT
    b.bucket_start,
    COUNT(l.listened_at) AS listen_count
  FROM buckets b
  LEFT JOIN filtered_listens l
    ON l.listened_at >= b.bucket_start
    AND l.listened_at < b.bucket_start + $3::interval
  GROUP BY b.bucket_start
  ORDER BY b.bucket_start
)
SELECT bucket_start, listen_count FROM bucketed_listens
`

type ListenActivityForArtistParams struct {
	Column1  time.Time
	Column2  time.Time
	Column3  pgtype.Interval
	ArtistID int32
}

type ListenActivityForArtistRow struct {
	BucketStart time.Time
	ListenCount int64
}

func (q *Queries) ListenActivityForArtist(ctx context.Context, arg ListenActivityForArtistParams) ([]ListenActivityForArtistRow, error) {
	rows, err := q.db.Query(ctx, listenActivityForArtist,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.ArtistID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListenActivityForArtistRow
	for rows.Next() {
		var i ListenActivityForArtistRow
		if err := rows.Scan(&i.BucketStart, &i.ListenCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listenActivityForRelease = `-- name: ListenActivityForRelease :many
WITH buckets AS (
  SELECT generate_series($1::timestamptz, $2::timestamptz, $3::interval) AS bucket_start
),
filtered_listens AS (
  SELECT l.track_id, l.listened_at, l.client, l.user_id
  FROM listens l
  JOIN tracks t ON l.track_id = t.id
  WHERE t.release_id = $4
),
bucketed_listens AS (
  SELECT
    b.bucket_start,
    COUNT(l.listened_at) AS listen_count
  FROM buckets b
  LEFT JOIN filtered_listens l
    ON l.listened_at >= b.bucket_start
    AND l.listened_at < b.bucket_start + $3::interval
  GROUP BY b.bucket_start
  ORDER BY b.bucket_start
)
SELECT bucket_start, listen_count FROM bucketed_listens
`

type ListenActivityForReleaseParams struct {
	Column1   time.Time
	Column2   time.Time
	Column3   pgtype.Interval
	ReleaseID int32
}

type ListenActivityForReleaseRow struct {
	BucketStart time.Time
	ListenCount int64
}

func (q *Queries) ListenActivityForRelease(ctx context.Context, arg ListenActivityForReleaseParams) ([]ListenActivityForReleaseRow, error) {
	rows, err := q.db.Query(ctx, listenActivityForRelease,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.ReleaseID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListenActivityForReleaseRow
	for rows.Next() {
		var i ListenActivityForReleaseRow
		if err := rows.Scan(&i.BucketStart, &i.ListenCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listenActivityForTrack = `-- name: ListenActivityForTrack :many
WITH buckets AS (
  SELECT generate_series($1::timestamptz, $2::timestamptz, $3::interval) AS bucket_start
),
filtered_listens AS (
  SELECT l.track_id, l.listened_at, l.client, l.user_id
  FROM listens l
  JOIN tracks t ON l.track_id = t.id
  WHERE t.id = $4
),
bucketed_listens AS (
  SELECT
    b.bucket_start,
    COUNT(l.listened_at) AS listen_count
  FROM buckets b
  LEFT JOIN filtered_listens l
    ON l.listened_at >= b.bucket_start
    AND l.listened_at < b.bucket_start + $3::interval
  GROUP BY b.bucket_start
  ORDER BY b.bucket_start
)
SELECT bucket_start, listen_count FROM bucketed_listens
`

type ListenActivityForTrackParams struct {
	Column1 time.Time
	Column2 time.Time
	Column3 pgtype.Interval
	ID      int32
}

type ListenActivityForTrackRow struct {
	BucketStart time.Time
	ListenCount int64
}

func (q *Queries) ListenActivityForTrack(ctx context.Context, arg ListenActivityForTrackParams) ([]ListenActivityForTrackRow, error) {
	rows, err := q.db.Query(ctx, listenActivityForTrack,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListenActivityForTrackRow
	for rows.Next() {
		var i ListenActivityForTrackRow
		if err := rows.Scan(&i.BucketStart, &i.ListenCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTrackIdForListens = `-- name: UpdateTrackIdForListens :exec
UPDATE listens SET track_id = $2
WHERE track_id = $1
`

type UpdateTrackIdForListensParams struct {
	TrackID   int32
	TrackID_2 int32
}

func (q *Queries) UpdateTrackIdForListens(ctx context.Context, arg UpdateTrackIdForListensParams) error {
	_, err := q.db.Exec(ctx, updateTrackIdForListens, arg.TrackID, arg.TrackID_2)
	return err
}
